# Practice 3: Avoid Obstacles üöó

This practice aims to design a **VFF-based algorithm** to make a racing car avoid obstacles on a track. A previous model has established a set of checkpoints (global navigation) where the car must go. For designing this local navigation algorithm, the following steps have been followed:

1. Design repulsive vectors to **obstacles**
2. Design an attractive vector to the next **checkpoint**
3. Combine both previous steps into a **VFF algorithm**

## 1. Obstacle Detection üöß

Before designing any forces, we must convert the values obtained from the laser (an array of 180 floats) to a prediction of where the obstacles could be. To achieve this, we defined a **threshold** where the values above this threshold are considered infinite. Values below the threshold allow us to distinguish **obstacles** separated by infinite values. From now on, we will consider each of these segments as a different obstacle.

> This idea has been implemented in the `Laser` class.

<div align="center">
    <img src="./images/p3_detection_edited.png" height="300px">
</div>

For each obstacle, we compute its center and its own vector by taking the **minimum** value of the laser readings as the distance to the obstacle, and we use the **median** of the obstacle's values to determine its direction.

Once all obstacles are detected, we apply an optimization trick. We assume that **smaller obstacles are more dangerous** than larger ones (e.g., walls are consistently avoided, while smaller obstacles, like cars on the track, must be avoided more quickly). Therefore, small obstacles are adjusted to **appear closer**, increasing their perceived importance, while larger obstacles are made to appear less critical.

This approach gives us a vector pointing to each obstacle on the track.

<div align="center">
    <img src="./images/p3_obstacle_detection.png" height="300px">
    <p>The simulation in this image has been modified to show the obstacles instead of the forces.</p>
</div>

> This idea has been implemented in the `Obstacle` class.

## 2. Checkpoints üéØ

Since the checkpoints are generated by the global navigation system, we don't need a detection algorithm. Instead, the vector to the next checkpoint **points directly** to that location, with its **module always kept below a specified threshold**.

We consider the checkpoint reached when the vector to the target is **less than 2m**. If the target is behind the car's relative position, it will also be marked as reached.

Although this technique might fail when the next target is behind the car, it **helps avoid confusion** when targets are misplaced and can be **safely disabled** if necessary.

<div align="center">
    <img src="./images/p3_comparision_targets.png" height="300px">
    <p>A well-placed target will be marked as reached when the module is less than 2m. Misplaced targets are considered reached once passed.</p>
</div>

> This idea has been implemented in the `Target` class.

## 3. VFF (Virtual Force Field) ‚ö°

To implement the VFF algorithm, we need to define a set of functions, **alpha** and **beta**, such that:

```c++
VFF = alpha(target_vector) + beta([obstacle_1, obstacle_2, ...])
```

### Alpha Function

The **alpha** function receives the target vector and adjusts its magnitude to increase its importance only if the target is close. This follows two main considerations:

- If the target is far, a small force should be applied only to direct the car.
- If the target is close, all corrections should be applied to successfully reach the target.

The function can be implemented as follows:

```python
f(x) = max(-mx + c, min_value)
```

<div align="center">
    <img src="./images/p3_alpha.png" height="300px">
</div>

### Beta FunctionÔ∏è

For the **beta** function, we apply it over the **summation of all obstacle vectors** (so we consider all the obstacles). With this, we use the **sigmoid function** following these considerations:

- If the target is far, the obstacle can be mostly ignored.
- If the target is getting closer, we want a function that reacts smoother than \(x^2\) or \(1/x\) but still reacts quickly.
- If the obstacle is very close, we don't want to enforce infinite values, as this would often make the car crash.

Furthermore, this approach can be easily adjusted to control the **proportion (P)**, **aggressiveness (A)**, and **reaction distance (D)** of the car by modifying the parameters.

```python
f(x) = P / (1 + e^(A * (x-D)))
```

<div align="center">
    <img src="./images/p3_sigmoid.png" height="300px">
</div>

Using the final VFF expression, we compute a directive vector that will guide the car in the appropriate direction. To translate the final vector into actions, we use the angle of the vector for **angular velocity** and its magnitude for **linear velocity**.

## üèÅ Results

<div align="center">
    <video width="600" controls>
        <source src="https://github.com/user-attachments/assets/9d0c5c38-2d10-4f4a-88b2-aaf203bf9525" type="video/mp4">
    </video>
</div>

